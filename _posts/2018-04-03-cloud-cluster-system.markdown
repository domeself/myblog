---
layout: post
title:  "分布式架构"
categories: springCloud
tags: springCloud
author: supernova
description: 分布式架构.
---
## 分布式架构的目的
### 提高系统性能
系统性能的好坏的指标，主要是指吞吐量和响应时间。  
吞吐量是用来衡量系统可同时处理用户访问的数值。
响应时间是指从用户发出请求到服务端的网络传输时间+服务端的处理时间+服务端到用户端的网络传输时间+用户端渲染页面的时间。  
系统的性能是由响应时间和吞吐量共同决定的。
#### 系统缓存
系统缓存可以有效的加快系统的读写力能(主要是读)，降低响应速度。从前端的浏览器，到网络(CDN)，再到后端的
服务(本地缓存，分布式缓存redis)，底层的数据库、文件系统、硬盘和CPU，全都有缓存，这是提高快速访问能力最有效的手段。
#### 负载均衡
负载均衡是水平扩展的关键技术，多台机器分担流量。
#### 异步调用
异步系统主要通过消息队列来对请求做排队处理，起到消峰的作用。所以它既提高吞吐量也减小了响应时间。
但是也会造成时效性差，而且还可能丢失数据。
#### 数据镜像
将数据源复制成多份，可以主写、从读。缺点是增加了编程难度和主从同步时产生的数据一致性问题。
### 提高系统稳定性
#### 服务拆分
服务拆分可以做到故障隔离和模块重用。但是会产生各个模块之间调用的依赖关系。
#### 服务冗余
服务冗余能做到弹性伸缩，低峰的时候去除闲置服务，高峰的时候增加应用服务。人为操作困难最好能做到系统自动伸缩。  
对于有状态的服务来说，伸缩的时候必须要做重新分区和数据的迁移。
#### 流量控制
当同个模块的多个服务流量偏移很大时，通过负载均衡和路由进行调节。
在系统的吞吐量已经达到极限时，为了保障系统的可用性会功能进行限流或者降级来停掉一部分服务。
#### 高可用运维
庞大的系统如果用人工来维护，不仅耗时耗力，而且对性能把控能力和故障的应激处理能力都不会比系统自己来的准确和快速。
一个高可用的运维系统至少要做到：
* 自动化的集成和发布
* 核心功能的实时监控和预警
* 故障的自动隔离和恢复
* 自动化的测试和输出结果

## 分布式系统的事务
### 无状态服务
服务调用涉及到的数据和服务本身没有依赖关系。
### 有状态服务
服务调用涉及到的数据存储在服务节点中，如果切换到冗余的另外一个节点，则无法获取服务调用方的信息。  
最常见的一个例子：如果用户登录成功后，系统将会员的信息缓存在session中，那么用户的后续操作如果被分配到另外的节点时，  
由于另外的节点没有session缓存，用户会被当做时未登录状态。对于这样的问题，在分布式系统中最常见的解决方案是将有状态服务变成无状态服务，  
也就是把数据放到第三方存储设备上，如redis，zookeeper等，每个节点都去操作同一个数据服务。  
分布式系统的事务主要是指应用层的无状态服务的事务，和数据层的有状态服务的事务。
### 数据层事务
为了保证数据层的高可用，就得多保存副本数据。当某个节点的数据丢失时，就从副本中找回。副本冗余是分布式系统解决数据丢失的唯一方法。    
既然存在副本，就一定会有数据一致性的问题，为了解决数据一致性的问题就会产生系统性能的问题。  
解决数据一致性的问题，有一些技术方案：  
* master-slave  
读写都由master负责，然后将数据从master同步到slave上。具体的同步方式可以是同步也可以是异步，既可以是master push给slave，也可以是slave 向master pull。  
* master-master  
一个系统存在2个或多个master，所有master都负责读写，然后master之前在同步数据。很显然这种方式属于最终一致性。它的好处是一台master挂了，另外的master可以继续读写。  
和master-slave一样当数据没有从master复制到其他master时宕机一样会丢失数据，而且当多个master对同一个数据做修改时，会造成数据冲突，需要进行数据合并操作。   
 
* 2Pc/3Pc  
在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。   
当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。 两阶段提交的算法如下：  
  
第一阶段：  
    * 协调者会问所有的参与者结点，是否可以执行提交操作。  
    * 各个参与者开始事务执行的准备工作：如：为资源上锁，预留资源，写undo/redo log  
    * 参与者响应协调者，如果事务的准备工作成功，则回应“可以提交”，否则回应“拒绝提交”。
         
第二阶段：  
    * 如果所有的参与者都回应“可以提交”，那么，协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各结点的“完成”回应后结束这个Global Transaction。  
    * 如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源，然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个Global Transaction。  

* paxos  
Paxos算法基本上来说是个民主选举的算法——大多数的决定会成个整个集群的统一决定。任何一个点都可以提出要修改某个数据的提案，是否通过这个提案取决于这个集群中是否有超过半数的结点同意（所以Paxos算法需要集群中的结点是单数）。    
第一阶段：Prepare阶段  
A把申请修改的请求Prepare Request发给所有的结点A，B，C。注意，Paxos算法会有一个Sequence Number（你可以认为是一个提案号，这个数不断递增，而且是唯一的，也就是说A和B不可能有相同的提案号），  
这个提案号会和修改请求一同发出，任何结点在“Prepare阶段”时都会拒绝其值小于当前提案号的请求。  
所以，结点A在向所有结点申请修改请求的时候，需要带一个提案号，越新的提案，这个提案号就越是是最大的。  
如果接收结点收到的提案号n大于其它结点发过来的提案号，这个结点会回应Yes（本结点上最新的被批准提案号），  
并保证不接收其它<n的提案。如果任何一个结点发现存在一个更高编号的提案，则需要通知 提案人，提醒其中断这次提案。  
第二阶段：Accept阶段  
如果提案者A收到了超过半数的结点返回的Yes，然后他就会向所有的结点发布Accept Request（同样，需要带上提案号n），如果没有超过半数的话，那就返回失败。  
当结点们收到了Accept Request后，如果对于接收的结点来说，n是最大的了，那么，它就会修改这个值，如果发现自己有一个更大的提案号，那么，结点就会拒绝修改。  

paxos是解决数据层事务的最好方案，zookeeper和redis使用的就是类型的方案。  
### 应用层事务
应用层事务解决方案最常见的就是2Pc/3Pc，例如：阿里巴巴的TCC(try、commit、cancel)

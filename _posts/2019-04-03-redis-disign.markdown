---
layout: post
title:  "cluster 集群"
categories: Redis
tags: Redis
author: supernova
description: 设计与优化
---
##  收益与成本
* 收益
    * 加速读写
    * 降低数据库负载
* 成本
    * 缓存与数据库数据不一致，和更新策略有关，但是无法完全避免。
    * 代码维护成本，多了缓存层的代码。
    * 设备和运维的成本。  
    
## 使用场景
* 降低数据库负载
    * 对高消耗，执行时间长sql负载：join结果集、分组统计结果。
    * 加速请求响应
    * 大量写合并为批量写，避免一次大量写操作，每写一次保存一次数据库。先存在缓存中，在一次性写入数据库。 

## 更新策略
* LRU/LFU/FIFO算法删除：maxmemory-policy，这类策略用于控制最大内存，例如一个集合不可能无限插入，
当集合满了有新的元素要加入的时候，就会根据策略删除它认为可以删除的元素。
* 超时expire，设定到期时间，定时失效。
* 主动更新，开发控制生命周期，如用户信息修改主动更新。

|策略|一致性|成本|
|:---:|:---:|:---:|
|算法策略|最差|低|
|超时|较差|低|
|主动|高|高|

对于低一致性的需求，使用算法策略、超时
对于高一致性的需求，千万不能只用主动失效，因为非常可能由于在某些特殊情况下没有主动更新，  
导致在下一次主动更新之前一直使用的是过期的数据。正确的做法是还要用过期失效或者算法策略兜底。

## 缓存粒度
以缓存会员信息为例：  
* 通用性:缓存全量更好   
因为有些属性虽然现在用不到，但是可能哪天来了新需求就会用到。用到的时候就要修改代码，更新缓存。  
* 节约性 缓存部分更好  
当缓存数据很多时，能节约客观的内存  
* 性能   
对缓存读写对象时，需要序列化和反序列化，这两个操作比较消耗性能。  
部分肯定比全量好，但是具体高多少也是和全量和部分的差值有关的。

缓存粒度是要综合考虑具体业务具体对待，就例子中的会员信息而言，本人觉得还是全量的好  
1.会员数据使用的频率太高了  
2.新增修改字段的概率很大
3.会员信息的字段绝大多数都是很有用的

## 缓存穿透
* 大量请求不命中，正常的流程是：  
1.一个请求过来，首先访问缓存，如果命中则返回。  
2.如果没命中则访问数据库，将数据缓存。  
如果大量请求一个数据库不存在的key，每次缓存都不可能命中(数据根本不存在)。    
造成每次都要去访问数据库，因为数据库中也不存在，所以不可能更新缓存。    
结果解释缓存形同虚设，数据库由于大量访问而崩溃。 
* 原因
    * 自身代码逻辑问题
    * 恶意攻击、爬虫
* 如何发现
    * 业务响应时间监控
    * 业务功能出现问题
    * 指标监控，每分钟 总调用数、缓存命中数、数据库命中数。
* 解决
    * 缓存空对象  
    问题：
    1.误判，可能当次查询错误导致没查到结果，所以要设置过期时间  
    2.需要存储非常多的key，值为空。还是用设置过期时间解决。  
    * 布隆过滤器  
    在缓存层之前先用布隆过滤器过滤掉一些认为是无效的key，布隆过滤器适用固定的数据，或者更新周期固定的数据，例如每天更新一次。  

## 无底洞问题
节点越多!=性能越高，2001年facebook的节点到达了3000多，在他们增加节点的时候，发现性能不仅没有提高反而下降了。  
* 原因  
对于一次批量操作，在单机下只用一次网络通信。而对于分布式而言，数据分布在不同的节点上，节点越多，需要网络通信的次数就越多，反而效率降低。
* 解决  
 * 串行mget
 * 串行IO
 * 并行IO
 * hash_tag
 
 ## 热点key重建优化
 
 ## 缓存雪崩
 
 ## 缓存击穿  

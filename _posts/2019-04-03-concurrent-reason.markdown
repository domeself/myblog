---
layout: post
title:  "并发编程问题源头"
categories: 多线程
tags:并发
author: supernova
description: 并发编程问题源头
---
## 可见性问题
摩尔定律是由英特尔（Intel）创始人之一戈登·摩尔（Gordon Moore）提出来的。  
其内容为：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。  
换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度。 
在早期cpu执行时要从计算机的主存中读取指令，后来由于cpu的性能飞速的提升而主存的读写速度远远不能满足cpu的需求，从而产生了cpu的高速缓存。  
cpu会将指令从主存中缓存到cpu中，减少对主存的访问，从而大幅提高执行效率。  
在单线程时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。  
因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。
一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。
多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，  
当多个线程在不同的 CPU上执行时，这些线程操作的是不同的 CPU 缓存。
例如多线程对变量累加
```
private long count = 0;
  private void add10K() {
    int idx = 0;
    while(idx++ < 10000) {
      count += 1;
    }
  }
```
在2个线程同时执行时，有可能获得的都是0，执行完 count+=1 之后，各自 CPU 缓存里的值都是1，同时写入内存后，我们会发现内存中是1，而不是我们期望的 2。  
之后由于各自的 CPU 缓存里都有了 count 的值，两个线程都是基于 CPU 缓存里的 count 值来计算，所以导致最终 count 的值都是小于 20000 的。    

## 线程切换带来的原子性
count = count + 1;是原子性操作吗？  
在高级语言里的一条语句通常包含多条cpu指令，例如count = count + 1在cpu层面至少需要3条指令来完成。
```
1.把count的值从内存加载到cpu的寄存器;
2.在寄存器中+1;
3.把count写回内存;
```
所以count = count + 1;并不是原子性操作。  
那么为什么原子性问题会导致线程安全性问题呢？  
由于 IO 太慢，早期的操作系统就发明了多进程，即便在单核的 CPU 上我们也可以一边听着歌，一边看视频。
操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行，这个 50 毫秒称为“时间片”。
所以线程在执行过程中随时可能丢失时间片。假设count初始为0，当A线程执行完2时刚好丢失时间片，B线程得到时间片顺序执行了1，2，3将count值改为1之后，A线程再次获得时间片后继续3步骤也将count的值改为了1。  
原本期望的2个线程执行后的结果应为2，结果却出乎意料。    

## 编译优化带来的顺序性问题  
有序性指的是程序按照代码的先后顺序执行  
在高级语言中，为了提升cpu的运行效率，在不影响运行结果的前提下，会对代码的执行顺序做出调换。  
这中优化在单线程下完全没有问题，但是在多线程下，却会造成并发问题。例如单例模式有个经典的双重检查
```
public class Singleton {
  static Singleton instance;
  static Singleton getInstance(){
    if (instance == null) {//
      synchronized(Singleton.class) {
        if (instance == null)//
          instance = new Singleton();
        }
    }
    return instance;
  }
}
```
假设有A、B两个线程同时访问getInstance方法，由于加了锁，假设B没抢到锁进入了对象池，而A获得了锁发现instance == null所以创建了一个实例。  
A执行完释放了锁，B获得了锁进入以后发现instance != null所以没有创建新的实例，返回了A创建的那一个。 
看起来程序设计的很完美，但其实B仍然可能也创建了一个实例。问题就出在了instance = new Singleton()上，我们理想中new操作应该是
1.分配一块内存  
2.在内存中初始化实例对象
3.将引用地址交给instance  
但实际上经过编译优化后却是这样的： 
1.分配一块内存  
2.将引用地址交给instance  
3.在内存中初始化实例对象  
如果当A执行完2步骤，丢失了时间片。此时B执行getInstance方法，发现instance != null直接返回了未实列化的对象，造成空指针。


